# -*- coding: utf-8 -*-
"""
Created on Thu Nov 23 14:47:35 2023

@author: asalehi
"""


'''

Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point


'''
import os

import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt

import numpy as np
import json

from statistics import mean

import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import matplotlib.ticker as mticker

# %% Initializing Data
def init_AQ_Grids(in_dir='Data/AQgrid.gpkg'):
    """
    Initializes and processes the AQ (Air Quality) Grids from a GeoPackage file.

    The function performs the following steps:
    1. Loads the AQ Grid GeoDataFrame from the specified file path.
    2. Converts the coordinate reference system (CRS) to EPSG:4326.
    3. Generates a unique 'GRID_KEY' for each grid based on its 'COL' and 'ROW'.
    4. Filters the GeoDataFrame to keep only the 'GRID_KEY' and 'geometry' columns.

    Parameters:
    - in_dir (str): Path to the input GeoPackage file containing the AQ Grids.
                    Defaults to 'Data/AQgrid.gpkg'.

    Returns:
    - GeoDataFrame: Processed GeoDataFrame containing the AQ Grids with updated CRS,
                    a new 'GRID_KEY', and only the essential columns.
    """
    # Load the AQ Grid GeoDataFrame from the specified GeoPackage file
    AQ_Grid_gdf = gpd.read_file(in_dir)
    
    # Convert the GeoDataFrame's coordinate reference system (CRS) to EPSG:4326
    AQ_Grid_gdf.crs = "EPSG:4326"
    
    # Generate a 'GRID_KEY' for each grid, combining 'COL' and 'ROW' values
    AQ_Grid_gdf['GRID_KEY'] = [str((col, row)) for col, row in zip(AQ_Grid_gdf['COL'], AQ_Grid_gdf['ROW'])]
    
    # Define the columns to keep in the final GeoDataFrame
    columns_to_keep = ['GRID_KEY', 'geometry']
    
    # Filter the GeoDataFrame to include only the specified columns
    AQ_Grid_gdf = AQ_Grid_gdf[columns_to_keep]
    
    # Return the processed GeoDataFrame
    return AQ_Grid_gdf



def init_County(in_dir='Data/County_Main_Land.gpkg'):
    """
    Initializes and processes the County geometries from a GeoPackage file.

    The function performs the following steps:
    1. Loads the County GeoDataFrame from the specified file path.
    2. Converts the coordinate reference system (CRS) to EPSG:4326.
    3. Filters the GeoDataFrame to keep only the 'FIPS' and 'geometry' columns.

    Parameters:
    - in_dir (str): Path to the input GeoPackage file containing County geometries.
                    Defaults to 'Data/County_Main_Land.gpkg'.

    Returns:
    - GeoDataFrame: Processed GeoDataFrame containing the County geometries with updated CRS,
                    including only the 'FIPS' code and geometry for each county.
    """
    # Load the County GeoDataFrame from the specified GeoPackage file
    County_gdf = gpd.read_file(in_dir)
    
    # Convert the GeoDataFrame's coordinate reference system (CRS) to EPSG:4326
    County_gdf.crs = "EPSG:4326"
    
    # Define the columns to keep in the final GeoDataFrame
    columns_to_keep = ['FIPS', 'geometry']
    
    # Filter the GeoDataFrame to include only the specified columns
    County_gdf = County_gdf[columns_to_keep]
    
    # Return the processed GeoDataFrame
    return County_gdf


def init_grid_contents_in_county_overlap_mapping(  in_dir = 'Data/Spatial_Grid_contents_in_County_Overlap_Percentages.json' ):
    #This function loads a pre calculated dictionary to map percentage of each county area located in each grid
    with open(in_dir, 'r') as file:
        grid_contents_in_county_overlap_mapping = json.load(file)
    
    return grid_contents_in_county_overlap_mapping

def init_county_contents_in_grid_overlap_mapping(  in_dir = 'Data/Spatial_County_contents_in_Grid_Overlap_Percentages.json' ):
    #This function loads a pre calculated dictionary to map percentage of county contents of a grid
    
    with open(in_dir, 'r') as file:
        county_contents_in_grid_overlap_mapping = json.load(file)

    return county_contents_in_grid_overlap_mapping

def init_PM_Concentrations( in_dir = 'Data/PM_Grid_Daily_Concentration_1981_2010.json'):
    # This Function loads PM2.5 Concentration per Grid Cell per year. 
    #Contains a string of 365 daily concentration
    with open(in_dir, 'r') as file:
        PM_Concentrations_dict = json.load(file)
    
    return PM_Concentrations_dict

def init_PM_Concentrations_means(in_dir = 'Data/PM_Grid_Daily_Mean_Concentration_1981_2010.json'):
    # This Function loads PM2.5 Concentration per Grid Cell per year, and returns the yearly mean value
    with open(in_dir, 'r') as file:
        PM_concentrations_mean_dict = json.load(file)
    
    return PM_concentrations_mean_dict

def init_Buildings_Stock( in_dir = 'Data/Buildings_Stock.csv'):
    #This Function Loads the Buildings Stock
    Buildings_Stock_df = pd.read_csv(in_dir)
    return Buildings_Stock_df

def init_ACH50(in_dir = 'Data/ACH50_Grid_1000sim.json'):
    #This function initilizes ACH50 across grid cells per building type
    #For each grid and building type 1000 mean ACH50 occupant based values is provided
    with open(in_dir, 'r') as file:
        ACH50_dict = json.load(file)
    return ACH50_dict

def init_ACH50_mean(in_dir = 'Data/ACH50_Grid_1000sim.json'):
    #This function initilizes ACH50 across grid cells per building type
    #For each grid and building type 1000 mean ACH50 occupant based values is provided
    with open(in_dir, 'r') as file:
        ACH50_dict = json.load(file)
        
    def calculate_average(lst):
        return sum(lst) / len(lst) if lst else 0

    def update_dict_with_averages(d):
        for key, value in d.items():
            if isinstance(value, list):
                # Calculate the average and update the dictionary if the value is a list
                d[key] = calculate_average(value)
            elif isinstance(value, dict):
                # Recursively update nested dictionaries
                update_dict_with_averages(value)
    
        # Updating the original nested dictionary
    update_dict_with_averages(ACH50_dict)
        
    return ACH50_dict

def init_Floor_Area(in_dir = 'Data/Floor_Area_Grid_1000sim.json'):
    #This function initilizes Floor area across grid cells per building type
    
    '''
    with open(in_dir, 'r') as file:
        Floor_Area_dict = json.load(file)
    
    return Floor_Area_dict
    '''
    return 2000

def init_Population( in_dir = 'Data/Population.csv'):
    #The Current Sate of The Model only Uses 2000 Population data based on Leuple 
    Population_df = pd.read_csv(in_dir)
    
    Population_dict = {}

    for index, row in Population_df.iterrows():
        population = row['2000']
        col_row_key = (row['COL'], row['ROW'])
        GRID_KEY = str(col_row_key)
        Population_dict[GRID_KEY] = population
        
    return Population_dict

def init_Population_Distribution( in_dir = 'Data/population_buildingtype_grid_percentage_mapping.json' ):
    with open(in_dir, 'r') as file:
        Population_Distribution = json.load(file)
    return Population_Distribution 

def init_Average_Occupancy():
    return 2

def init_Baseline_Mortality( in_dir = 'Data/Baseline_Mortality.json'):
    
    with open(in_dir, 'r') as file:
        Baseline_Mortality_dict = json.load(file)
    return Baseline_Mortality_dict
        
def init_VSL():
    return 7000000

def init_Health_Model():
    #This values need to be Corrected
    Baseline_Mortality_dict = init_Baseline_Mortality()
    Relative_Risk = 1.14
    VSL = init_VSL()
    
    return VSL, Relative_Risk, Baseline_Mortality_dict

def init_Adaptation_Type( in_dir = 'Data/Adaptation_Types.csv' ):
    
    Adaptation_Types_df = pd.read_csv(in_dir)
    
    Adaptation_Cost_dict = Adaptation_Types_df.set_index('ATYPE')['COST'].to_dict()
    Adaptation_Impact_dict = Adaptation_Types_df.set_index('ATYPE')['IMPACT'].to_dict()
    
    return Adaptation_Cost_dict, Adaptation_Impact_dict
'''
def init_phi():
    
    phi = { 'Multi-Family with 5+ Units': 0.17, 'Multi-Family with 2 - 4 Units': 0.078,
             'Single-Family Attached': 0.059, 'Single-Family Detached': 0.631,
             'Mobile Home': 0.061}
    return phi
'''

def init_phi():
    
    phi = init_Population_Distribution()
    return phi
# %% Buildingd Part

def ACH50_to_INF(ACH_50, P=0.97, K=0.39, F=20):
    """
    Convert blower door test results (ACH_50) to natural infiltration rate (Finf).

    This function estimates the natural infiltration rate based on the air change rate at
    50 Pascals (ACH_50) from blower door tests. It accounts for the penetration factor of
    particulate matter (P), the deposition rate (K), and the conversion factor (F) to
    adjust ACH_50 to ACH_natural.

    Parameters:
    - ACH_50 (float): Air Change per Hour at 50 Pascals from a blower door test.
    - P (float): Penetration factor representing how much particulate matter gets inside. Default is 0.97.
    - K (float): Deposition factor representing how fast particulate matter settles. Default is 0.39.
    - F (float): Conversion factor to relate ACH_50 to natural air change rate. Default is 20.

    Returns:
    - float: The natural infiltration rate (Finf).

    Notes:
    - The user of this function should consider local building codes and literature for appropriate values of P, K, and F.
    - The default values provided may not be suitable for all building types and climates.
    """
    # Convert ACH_50 to natural air change rate (ACH_natural)
    ACH_natural = ACH_50 / F
    
    # Calculate natural infiltration rate (Finf)
    Finf = (P * ACH_natural) / (ACH_natural + K)
    
    return Finf


def Intervention_Cost_Air_Sealing(Floor_Area, Adaptation_Cost):
    Intervention_Cost_Air_Sealing_Value = Floor_Area * Adaptation_Cost
    return Intervention_Cost_Air_Sealing_Value

#%% Exposure

def concentration_indoor_calculator(Finf, C_out):
    """
    Calculate the indoor concentration of a pollutant.

    This function computes the indoor concentration of a pollutant based on the
    outdoor concentration and the infiltration factor.

    Parameters:
    - Finf (float): The infiltration factor, representing the fraction of outdoor
                    air pollutants that penetrate indoors.
    - C_out (float): The outdoor concentration of the pollutant.

    Returns:
    - float: The calculated indoor concentration of the pollutant.
    """

    # Calculate the indoor concentration
    C_in = C_out * Finf

    return C_in

def mean_concentration_indoor_calculator(phi, FINF, C_out):
    """
    Calculate the mean indoor concentration of a pollutant, weighted by the
    percentage of people living in different building sections.

    This function computes the mean indoor concentration by considering the
    outdoor concentration, the infiltration factors for different building
    sections, and the distribution of people across these sections.

    Parameters:
    - phi (dict): A dictionary mapping building sections to the percentage of
                  people living in each section. Keys represent section identifiers,
                  and values are the percentage (as a float) of people in each section.
    - FINF (dict): A dictionary mapping building sections to their infiltration
                   factors. Keys represent section identifiers, and values are
                   the infiltration factors (as floats) for each section.
    - C_out (float): The outdoor concentration of the pollutant.

    Returns:
    - float: The mean indoor concentration of the pollutant, weighted by the
             distribution of people across building sections.

    Note: It is assumed that `concentration_indoor_calculator` is a previously
    defined function that calculates the indoor concentration for a given
    infiltration factor and outdoor concentration.
    """
    
    mean_C_in = 0  # Initialize mean indoor concentration
    C_in = {}  # Dictionary to store indoor concentrations for each section
    residences_segment = FINF.keys()  # Building sections
    
    for j in residences_segment:
        Finf = FINF[j]  # Infiltration factor for the section
        C_in[j] = concentration_indoor_calculator(Finf, C_out)  # Calculate indoor concentration
        mean_C_in += C_in[j] * phi[j]  # Weighted sum of indoor concentrations
        
    return mean_C_in


def delta_exposure_calculator(t_in, phi, FINF_baseline, FINF_intervention, C_out):
    """
    Calculate the change in exposure to a pollutant indoors due to an intervention.

    This function computes the difference in mean indoor concentrations of a pollutant
    between a baseline scenario and an intervention scenario, then calculates the 
    change in exposure using time spend indoors.

    Parameters:
    - t_in (float): The time period over which exposure is calculated, in the same units
                    as used for concentration (e.g., hours).
    - phi (dict): A dictionary mapping building sections to the percentage of
                  people living in each section. Keys are section identifiers,
                  and values are percentages of people.
    - FINF_baseline (dict): Infiltration factors for each building section under the
                            baseline scenario. Keys are section identifiers, and values
                            are infiltration factors.
    - FINF_intervention (dict): Infiltration factors for each building section under the
                                intervention scenario. Keys are section identifiers, and
                                values are infiltration factors.
    - C_out (float): The outdoor concentration of the pollutant.

    Returns:
    - Tuple: 
        - mean_C_in_delta (float): The difference in mean indoor concentrations between
                                   the intervention and baseline scenarios.
        - delta_exposure (float): The change in exposure to the pollutant over the
                                  specified time period, calculated using the difference
                                  in mean indoor concentrations.

    Note: Assumes the existence of a `mean_concentration_indoor_calculator` function that
    calculates the mean indoor concentration for given phi, FINF, and C_out parameters.
    """
    
    # Calculate mean indoor concentrations for baseline and intervention scenarios
    mean_C_in_baseline = mean_concentration_indoor_calculator(phi, FINF_baseline, C_out)
    mean_C_in_intervention = mean_concentration_indoor_calculator(phi, FINF_intervention, C_out)
    
    # Compute the difference in mean indoor concentrations due to the intervention
    mean_C_in_delta = mean_C_in_intervention - mean_C_in_baseline
    
    # Calculate the change in exposure over the specified time period
    delta_exposure = t_in * mean_C_in_delta
    
    return mean_C_in_delta, delta_exposure


def baseline_exposure_calculator( FINF, Cout, phi):
    return 0

def intervention_exposure_calculator( FINF, Cout, phi, Adaptation_Impact):
    return 0
'''

def Adaptation_Exposure( FINF, Cout, phi, Adaptation_Impact):
    BT_list = FINF.keys()
    AE = 0
    phi_bt_mapping = { 'Single-Family Detached': 'SDA', 'Single-Family Attached': 'SDA', 'Multi-Family with 2 - 4 Units':'2-4', 'Multi-Family with 5+ Units':'5P', 'Mobile Home':'M'}

    for BT in BT_list:
        phi_bt = phi_bt_mapping[BT]
        #Temporary
        if pd.isna(FINF[BT]):
            #print("ACH50 is empty or NaN.")
            FINF[BT] = 0
        
        #Temporary
        
        Cin = FINF[BT] * Cout * Adaptation_Impact
        if BT == 'Single-Family Attached':
            AE += 0
        else:
            AE += Cin * phi[phi_bt]
        
    return AE
'''

# %% Health Model


def psi_modifier(t_r, t_out, t_v, t_other, F_r, F_v, F_other):
    """
    Calculate the exposure modifier (psi) based on the time spent and infiltration factors in various microenvironments.

    The psi modifier represents the relative impact of different environments on an individual's
    overall exposure to outdoor pollutants, given the infiltration factors of those environments
    and the proportion of time spent in each.

    Parameters:
    - t_r (float): Fraction of time spent in residence.
    - t_out (float): Fraction of time spent outdoors.
    - t_v (float): Fraction of time spent in vehicles.
    - t_other (float): Fraction of time spent in other environments.
    - F_r (float): Infiltration factor for residence, the main focus of this study.
    - F_v (float): Infiltration factor for vehicles.
    - F_other (float): Infiltration factor for other environments.

    Returns:
    - float: The exposure modifier (psi) reflecting the weighted impact of time spent and infiltration across environments.

    Note:
    - The psi is dimensionless and provides a way to adjust exposure estimates to reflect time-activity patterns.
    """
    # Calculate the exposure modifier (psi)
    psi = t_r / (t_out + t_v * F_v + t_other * F_other + t_r * F_r)

    return psi


def HF_1(Y_0, RR, dC_in, psi):
    """
    Calculate the change in risk of mortality based on a linear concentration-response function.

    This function uses the baseline mortality rate (BMR), relative risk (RR),
    change in indoor concentration of a pollutant (dC_in), and a proportionality
    constant (psi) to estimate the change in risk of mortality (dY).

    Parameters:
    - Y_0 (float): Baseline mortality rate (BMR), representing the initial risk of mortality.
    - RR (float): Relative risk associated with exposure to the pollutant.
    - dC_in (float): Change in indoor concentration of the pollutant.
    - psi (float): Proportionality constant linking the change in concentration to the change in risk.

    Returns:
    - float: The estimated change in risk of mortality (dY) due to the change in pollutant concentration.

    Notes:
    - The attributable fraction (AF) is calculated as (RR - 1) / RR.
    - The change in risk of mortality (dY) is calculated as Y_0 * AF * dC_in * psi.
    """
    
    # Calculate the attributable fraction (AF) based on relative risk (RR)
    AF = (RR - 1) / RR
    
    # Calculate the change in risk of mortality (dY)
    dY = Y_0 * AF * (dC_in/10) * psi
    
    return dY


def HF_2(Y_0, beta, dC_in, psi):
    """
    Calculate the change in health outcome using an exponential concentration-response function.

    This function uses the baseline health outcome rate (Y_0), the coefficient beta (β),
    the change in concentration (dC_in), and the exposure duration adjustment (psi),
    to estimate the change in health outcome (ΔY) using an exponential CRF.

    Parameters:
    - Y_0 (float): Baseline health outcome rate.
    - beta (float): The coefficient representing the strength of association between the pollutant
                    concentration change and the health outcome change.
    - dC_in (float): The change in indoor concentration of the pollutant.
    - psi (float): The exposure duration adjustment factor.

    Returns:
    - float: The estimated change in health outcome (ΔY).

    Notes:
    - The equation used is ΔY = Y_0 * (e^(β * ΔC_residence,mean,a * ψ) - 1).
    """
    # Calculate the change in health outcome (ΔY) using the exponential CRF
    dY = Y_0 * (np.exp(beta * dC_in * psi) - 1)
    
    return dY

def HF_3(Y_0, beta, dC_in, psi):
    """
    Calculate the change in health outcome using an exponential concentration-response function.

    This function uses the baseline health outcome rate (Y_0), the coefficient beta (β),
    the change in concentration (dC_in), and the exposure duration adjustment (psi),
    to estimate the change in health outcome (ΔY) using an exponential CRF.

    Parameters:
    - Y_0 (float): Baseline health outcome rate.
    - beta (float): The coefficient representing the strength of association between the pollutant
                    concentration change and the health outcome change.
    - dC_in (float): The change in indoor concentration of the pollutant.
    - psi (float): The exposure duration adjustment factor.

    Returns:
    - float: The estimated change in health outcome (ΔY).

    Notes:
    - The equation used is ΔY = Y_0 * (e^(β * ΔC_residence,mean,a * ψ) - 1).
    """
    # Calculate the change in health outcome (ΔY) using the exponential CRF
    dY = -Y_0 * (np.exp(-beta * dC_in * psi) - 1)
    
    return dY

def delta_mortality_calculator(dY, Pop):
    """
    Calculate the change in the number of mortalities based on the change in risk and population size.

    Parameters:
    - dY (float): The change in risk of mortality.
    - Pop (int/float): The population size affected by the change in risk.

    Returns:
    - float: The change in the number of mortalities (dMort).
    """
    dMort = dY * Pop
    return dMort

def health_benefit_calculator(dMort, VSL):
    """
    Calculate the health benefits in monetary terms based on the change in mortality and the value of a statistical life (VSL).

    Parameters:
    - dMort (float): The change in the number of mortalities.
    - VSL (float): The value of a statistical life, which is the monetary value assigned to a change in the risk of mortality.

    Returns:
    - float: The total health benefits in monetary terms.
    """
    benefits = dMort * VSL
    return benefits

#%% NPV Part
def PV_Convertor(Interest_Rate, Base_Year, Secondary_Year, Value):
    
    #Interest Rate in percentage : Interest_Rate = 10
    
    Delta_Year = Secondary_Year - Base_Year
    PV = Value / (1 + (Interest_Rate/100)) ** Delta_Year
    return PV


def NPV_Calculation( PV_Cost, PV_Benefit):
    NPV = PV_Benefit - PV_Cost
    return NPV

def GRID_NPV():
    return

#%% Model Run



#%% Plot Functions

#Setting the name of save folder
from datetime import datetime
# Get the current date
current_date = datetime.now()
# Format the date as 'MonthDay' without spaces
date_str = current_date.strftime("%B%d")
image_base_save_dir = r'C:\Users\asalehi\OneDrive - University of Waterloo\Documents - SaariLab\CVC\Buildings\Amirreza\Adaptation\Plots'
image_save_dir = os.path.join(image_base_save_dir, date_str)

def plot_geodataframe(gdf, title, column_to_plot, cmap='jet', figsize=(10, 6),
                      title_fontsize=16, legend_fontsize=12, legend_tag = 'dollar', save = False):
    # Create the plot
    fig, ax = plt.subplots(1, 1, figsize=figsize)
    
    # Plot the GeoDataFrame
    gdf.plot(column=column_to_plot, ax=ax, legend=True, cmap=cmap,
             legend_kwds={'label': legend_tag})

    # Remove the axis for a cleaner look
    ax.set_axis_off()
    
    ax.set_title(title, fontsize=title_fontsize)
    
    # Adjust the layout to make space for the title and legend
    plt.subplots_adjust(top=0.85, bottom=0.2)
    if save == True:
        plt.savefig(image_save_dir + '/'+ title, dpi=300, bbox_inches='tight')
    # Show the plot
    plt.show()

def plot_geodataframe_large(gdf, title, column_to_plot, cmap='jet', figsize=(10, 6),
                      title_fontsize=16, legend_fontsize=12, legend_tag = 'dollar', save = False):
    """
    Plots a GeoDataFrame with enhancements, including a title and a legend in millions.
    
    Parameters:
    - gdf: GeoDataFrame to plot.
    - title: Title for the plot.
    - column_to_plot: The name of the column in the GeoDataFrame to base the plot on.
    - cmap: Colormap for the plot.
    - figsize: Size of the figure.
    - title_fontsize: Font size for the plot title.
    - legend_fontsize: Font size for the legend.
    """
    # Create the plot
    fig, ax = plt.subplots(1, 1, figsize=figsize)

    # Plot the GeoDataFrame
    plot = gdf.plot(column=column_to_plot, ax=ax, legend=True, cmap=cmap,
                    legend_kwds={'label': 'Milion'+legend_tag, 'format': mticker.FuncFormatter(lambda v, pos: f'{v * 1e-6:,.0f}  ')})
    
    # Add the title to the plot
    ax.set_title(title, fontsize=title_fontsize)
    
    # Remove the axis for a cleaner look
    ax.set_axis_off()
    
    # Customize the legend
    # Get the figure's colorbar instance and modify its label
   # fig.colorbar(plot.get_children()[0], ax=ax, 
   #              format=mticker.FuncFormatter(lambda v, pos: f'{v * 1e-9:,.0f} M'))
    
    # Adjust the layout to make space for the title and legend
    
    plt.subplots_adjust(top=0.85, bottom=0.2)
    if save == True:
        plt.savefig(image_save_dir + '/'+ title, dpi=300, bbox_inches='tight')
    # Show the plot
    plt.show()
    
def plot_histogram(data, title, xlabel, ylabel, color='skyblue', edgecolor='black', save = False):
    """
    Plots a histogram with the given data and customization options.

    Parameters:
    - data: Pandas Series containing the data to plot.
    - title: String, title of the histogram.
    - xlabel: String, label for the x-axis.
    - ylabel: String, label for the y-axis.
    - color: String, color of the histogram bars. Default is 'skyblue'.
    - edgecolor: String, color of the bar edges. Default is 'black'.
    """
    plt.figure(figsize=(8, 6))  # Set figure size for better visibility
    data.hist(color=color, edgecolor=edgecolor)
    
    # Add titles and labels
    plt.title(title, fontsize=15)
    plt.xlabel(xlabel, fontsize=12)
    plt.ylabel(ylabel, fontsize=12)
    
    # Optional: Add grid for better readability
    plt.grid(axis='y', alpha=0.75)

    plt.show()

#%% Tests