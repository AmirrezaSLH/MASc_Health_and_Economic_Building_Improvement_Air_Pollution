# -*- coding: utf-8 -*-
"""
Created on Thu Nov 23 14:47:35 2023

@author: asalehi
"""


'''

Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point
Please Do not Edit this file on Share Point


'''

import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt

import numpy as np
import json

Out_Put_Dir = r'C:\Users\asalehi\OneDrive - University of Waterloo\Documents - SaariLab\CVC\Buildings\Amirreza\Adaptation\Github_Adaptation\MASc_Waterloo_Adaptation_Buildings\Data'

#%% Plot Functions 
def NPV_Plot(gdf_list, PNG_Dir = r'C:\Users\asalehi\OneDrive - University of Waterloo\Documents - SaariLab\CVC\Buildings\Amirreza\Adaptation\Plots\Beta\\'):
    
    y = 1981
    for i in gdf_list:
        i.plot( column = i['Benefit_individal'], legend = True, cmap= 'turbo' )
        plt.title('Individual' + str(y))
        plt.savefig(PNG_Dir + 'INDIVIDUAL' + str(y) +'.PNG')
        #i.plot( column = i['Benefit_pop'], legend = True, cmap = 'turbo')
        #plt.title('POP' + str(y))
        #plt.savefig(PNG_Dir + 'Population' + str(y) +'.PNG')
        y += 1
    return

def Map_Plot(gdf, value, title, pallet = 'turbo', name = '1', PNG_dir = r'C:\Users\asalehi\OneDrive - University of Waterloo\Documents - SaariLab\CVC\Buildings\Amirreza\Adaptation\Plots\\'):
    gdf.plot(column = value, legend = True, cmap = pallet)
    plt.title(title, fontsize=9.5)
    plt.savefig(PNG_dir + name+'.PNG')
    return

def Plot_Histogram(Plot_Values ,Plot_Title):
    # Plotting the histogram
    n, bins, patches = plt.hist(Plot_Values)
    #sum_n = sum(n)
    #n = n / sum_n
    #n = n = np.around(100 * (n / sum_n), 2)
    # Adding count above each bar
    for count, patch in zip(n, patches):
        plt.text(patch.get_x() + patch.get_width() / 2, patch.get_height(), 
                 f'{int(count)}', ha='center', va='bottom')
    
    # Setting the title
    plt.title(Plot_Title)
    
    # Show the plot
    plt.show()
    
    return
# %% Initializing Functions
def init_AQ_Grids( dir = 'Data/AQgrid.gpkg'):
    #This Function Loads the AQ Grids
    AQ_Grid_gdf = gpd.read_file(dir)
    AQ_Grid_gdf['GRID_KEY'] = [(col, row) for col, row in zip(AQ_Grid_gdf['COL'], AQ_Grid_gdf['ROW'])]
    AQ_Grid_gdf.crs = "EPSG:4326"

    return AQ_Grid_gdf

test_init_AQ_Grids = init_AQ_Grids()

def init_County( dir = 'Data/County_Main_Land.gpkg'):
    #This Function Loads the Counties
    County_gdf = gpd.read_file(dir)
    County_gdf.crs = "EPSG:4326"
    
    return County_gdf

test_init_County = init_County()

def init_Country_to_Grid_Percentage_Mapping(  dir = 'Data/County_to_Grid_percentage_mapping.json' ):
    with open(dir, 'r') as file:
        Country_to_Grid_Percentage_Mapping = json.load(file)
    
    return Country_to_Grid_Percentage_Mapping

def init_PM_Concentrations( in_dir = 'Data/PM_Grid_Daily_Concentration_1981_2010.csv'):
    # This Function loads PM2.5 Concentration per Grid Cell per year. 
    #The Values column contains a string of 365 daily concentration
    PM_Concentrations_df = pd.read_csv(in_dir)
    
    PM_Concentrations_dict = {}

    for index, row in PM_Concentrations_df.iterrows():
        year = row['Year']
        
        col_row_key = (row['COL'], row['ROW'])
        GRID_KEY = str(col_row_key)
        
        mean_value = row['Mean']
    
        if year not in PM_Concentrations_dict:
            PM_Concentrations_dict[year] = {}
    
        PM_Concentrations_dict[year][GRID_KEY] = mean_value
    
    return PM_Concentrations_df, PM_Concentrations_dict

test_init_PM_Concentrations_df, test_init_PM_Concentrations_dict = init_PM_Concentrations()

test_init_PM_Concentrations_df, test_init_PM_Concentrations_dict = init_PM_Concentrations()

def init_Buildings_Stock( dir = 'Data/Buildings_Stock.csv'):
    #This Function Loads the Buildings Stock
    Buildings_Stock_df = pd.read_csv(dir)
    return Buildings_Stock_df

test_init_Buildings_Stock = init_Buildings_Stock()

def init_Population( dir = 'Data/Population.csv'):
    #The Current Sate of The Model only Uses 2000 Population data based on Leuple 
    Population_df = pd.read_csv(dir)
    
    Population_dict = {}

    for index, row in Population_df.iterrows():
        population = row['2000']
        row_col_key = (row['COL'], row['ROW'])
        GRID_KEY = str(row_col_key)
        Population_dict[GRID_KEY] = population
    return Population_df, Population_dict

def init_Health_Model():
    #This values need to be Corrected
    Baseline_Mortality = 0.01
    Relative_Risk = 1.14
    VSL = 7000000
    return Baseline_Mortality, Relative_Risk, VSL

def init_Retrofit_Type( dir = 'Data/Retrofit_Types.csv' ):
    
    Retrofit_Types_df = pd.read_csv(dir)
    return Retrofit_Types_df

# %% Buildingd Part
'''
def PM_to_Grid_gdf(PM_Concentrations = init_PM_Concentrations() , AQ_Grid_gdf = init_AQ_Grids()): 
    return
'''

def County_to_Grid_mapping(County_gdf = init_County(),AQ_Grid_gdf = init_AQ_Grids()):
    County_gdf['centroid'] = County_gdf.geometry.centroid
    County_to_Grid_mapping_dict = {}

    for index, grid_row in AQ_Grid_gdf.iterrows():
        for _, county_row in County_gdf.iterrows():
            # Check if the centroid of the county is within the current grid cell
            if county_row['centroid'].within(grid_row['geometry']):
                # Create a mapping: FIPS -> (COL, ROW)
                row_col_key = (grid_row['COL'], grid_row['ROW'])
                GRID_KEY = str(row_col_key)
                County_to_Grid_mapping_dict[county_row['FIPS']] = GRID_KEY

    return County_to_Grid_mapping_dict

test_County_to_Grid_mapping = County_to_Grid_mapping()

def County_to_Grid_percentage_mapping(County_gdf = init_County(),AQ_Grid_gdf = init_AQ_Grids()):
    
    county_columns_to_keep = ['FIPS', 'geometry']
    ci = County_gdf[county_columns_to_keep].copy()
    
    grid_columns_to_keep = ['GRID_KEY', 'geometry']
    AQgrid = AQ_Grid_gdf[grid_columns_to_keep].copy()
    
    ci.crs = "EPSG:4326"
    AQgrid.crs = "EPSG:4326"
    
    ci = ci.to_crs("EPSG:5070")
    AQgrid = AQgrid.to_crs("EPSG:5070")
    
    ci['Country_Area'] = ci.area
    
    joined = gpd.overlay(AQgrid, ci, how = 'intersection')
    # Calculate Joined area
    joined['Intersect_Area'] = joined.area
    # Caclulcate percentage of DMA area in each grid cell
    joined['Percentage_Area'] = (joined['Intersect_Area']/joined['Country_Area'])
    
    joined_copy = joined.copy()
    
    County_to_Grid_percentage_mapping_dict = {}
    County_List = joined['FIPS'].unique().tolist()
    print(len(County_List))
    i = 0
    for c in County_List:
        County_to_Grid_percentage_mapping_dict[c] = {}
        i +=1
        print(i)
        for IDX, row in joined_copy.iterrows():
            # Check if the centroid of the county is within the current grid cell
            if row['FIPS'] == c:
                GRID_KEY = str(row['GRID_KEY'])
                County_to_Grid_percentage_mapping_dict[c][ GRID_KEY ] = row['Percentage_Area']
                #joined_copy = joined_copy.drop(joined_copy.index[IDX])
    
    return joined, County_to_Grid_percentage_mapping_dict

def Buildings_to_Grid(Buildings_Stock_df = init_Buildings_Stock(), County_to_Grid_mapping_dict = County_to_Grid_mapping() ):
    Buildings_Stock_df['GRID_KEY'] = Buildings_Stock_df['FIPS'].map(County_to_Grid_mapping_dict)
    return Buildings_Stock_df

test_Buildings_to_Grid = Buildings_to_Grid()

def ACH50_to_Grid(Buildings_Stock_df = Buildings_to_Grid(), AQ_Grid_gdf = init_AQ_Grids() ):

    Grid_list = Buildings_Stock_df['GRID_KEY'].unique().tolist()
    BT_List = Buildings_Stock_df['type'].unique().tolist()
    
    Buildings_Stock_df_Copy = Buildings_Stock_df.copy(deep = True)
    Buildings_Stock_df_Copy['ACH50_occupants'] = Buildings_Stock_df_Copy['ACH50'] * Buildings_Stock_df_Copy['occupants']
    ACH50_BT_dict = dict()
    
    for BT in BT_List:
        Target_Building = Buildings_Stock_df_Copy[ Buildings_Stock_df_Copy['type'] == BT]
        ACH50_dict = dict()
        
        for G in Grid_list:
            Target_Stock = Target_Building[ Target_Building['GRID_KEY'] == G]
            Occupants_sum = Target_Stock['occupants'].sum()
            ACH50_mean = Target_Stock['ACH50_occupants'].sum() / Occupants_sum
            ACH50_dict.update( {G : ACH50_mean} )
            
        ACH50_BT_dict.update( {BT : ACH50_dict} )

    return ACH50_BT_dict

#%%
def ACH50_to_County_2(Buildings_Stock_df = init_Buildings_Stock(), County_gdf = init_County() ):
    #This Function assigns average value of ACH50 to each County
    #The Current Method for Averaging is per building
    County_List = County_gdf['FIPS'].to_list()
    BT_List = Buildings_Stock_df['type'].unique().tolist()
    Buildings_Stock_df_Copy = Buildings_Stock_df.copy(deep = True)
    ACH50_dict = dict()
    for C in County_List:
        Target_Stock = Buildings_Stock_df_Copy[ Buildings_Stock_df_Copy['FIPS'] == C]
        ACH50_BT_dict = dict()
        for BT in BT_List:
            Target_Building = Target_Stock[ Target_Stock['type'] == BT]
            ACH50_mean = Target_Building['ACH50'].mean()
            ACH50_BT_dict.update({ BT : ACH50_mean})
        ACH50_dict.update({ C : ACH50_BT_dict})
        
    #County_gdf['ACH50_mean'] = County_gdf['FIPS'].map(ACH50_dict)
    #return County_gdf

    return ACH50_dict

def ACH50_to_County_1(Buildings_Stock_df = init_Buildings_Stock(), County_gdf = init_County() ):
    #This Function assigns average value of ACH50 to each County
    #The Current Method for Averaging is per building
    County_List = County_gdf['FIPS'].to_list()
    BT_List = Buildings_Stock_df['type'].unique().tolist()
    Buildings_Stock_df_Copy = Buildings_Stock_df.copy(deep = True)
    ACH50_BT_dict = dict()
    for BT in BT_List:
        Target_Building = Buildings_Stock_df_Copy[ Buildings_Stock_df_Copy['type'] == BT]
        ACH50_dict = dict()
        for C in County_List:
            Target_Stock = Target_Building[ Target_Building['FIPS'] == C]

            ACH50_mean = Target_Stock['ACH50'].mean()
            ACH50_dict.update({ C : ACH50_mean})
        ACH50_BT_dict.update({ BT : ACH50_dict})
        
    #County_gdf['ACH50_mean'] = County_gdf['FIPS'].map(ACH50_dict)
    #return County_gdf

    return ACH50_BT_dict

def ACH50_to_County(Buildings_Stock_df = init_Buildings_Stock(), County_gdf = init_County() ):
    #This Function assigns average value of ACH50 to each County
    #The Current Method for Averaging is per building
    County_List = County_gdf['FIPS'].to_list()
    BT_List = Buildings_Stock_df['type'].unique().tolist()
    Buildings_Stock_df_Copy = Buildings_Stock_df.copy(deep = True)
    Buildings_Stock_df_Copy['ACH50_occupants'] = Buildings_Stock_df_Copy['ACH50'] * Buildings_Stock_df_Copy['occupants']
    ACH50_BT_dict = dict()
    for BT in BT_List:
        Target_Building = Buildings_Stock_df_Copy[ Buildings_Stock_df_Copy['type'] == BT]
        ACH50_dict = dict()
        for C in County_List:
            Target_Stock = Target_Building[ Target_Building['FIPS'] == C]
            occupants_sum = Target_Stock['occupants'].sum()
            ACH50_mean = Target_Stock['ACH50_occupants'].sum() / occupants_sum
            ACH50_dict.update( {C : ACH50_mean} )
        ACH50_BT_dict.update( {BT : ACH50_dict} )
        
    #County_gdf['ACH50_mean'] = County_gdf['FIPS'].map(ACH50_dict)
    #return County_gdf

    return ACH50_BT_dict



def County_to_Grid_22(County_gdf, AQ_Grid_gdf):
    # I've done something similar in 
    '''
    County_gdf = County_gdf.to_crs("EPSG:5070")
    AQ_Grid_gdf = AQ_Grid_gdf.to_crs("EPSG:5070")
    
     # Calculate areas for counties and grids
    counties_gdf['area_county'] = counties_gdf.area
    grid_gdf['area_grid'] = grid_gdf.area
    
    # Find intersections
    intersections = gpd.overlay(AQ_Grid_gdf, County_gdf, how='intersection')
    intersections['area_intersection'] = intersections.area
    
     # Calculate percentage of county area in each grid cell
    intersections['percentage_area'] = (intersections['area_intersection'] / intersections['area_county'])
    
     # Create the nested dictionary
    nested_dict = {}
    for index, row in intersections.iterrows():
        key = (row['COL'], row['ROW'])
        if key not in nested_dict:
            nested_dict[key] = {}
        nested_dict[key][row['FIPS']] = row['percentage_area']
        return 0
    '''




def ACH50_to_INF( ACH_50):
    # There are a few ways to do this. One is shown below, from Amy Li
    # MS note, I think the P value is high here and gives high FINF values
    ACH_Natural = ACH_50 / 20
    P = 0.97 # Penetration factor (how much PM gets inside)
    K = 0.39 # Deposition factor (how fast PM settles)
    F_INF = (P * ACH_Natural) / (ACH_Natural + K)
    return F_INF

def Costs_Retrofit(Building_Area, Retrofit_Type, Retrofit_Types_dict):
    Cost = Building_Area * Retrofit_Types_dict[Retrofit_Type]['COST']
    return Cost

# %% Health Model
def Delta_Exposure_Calculator(PM_Concentration, Old_F_INF, New_F_INF):
    Delta_Exposure = PM_Concentration * ( Old_F_INF - New_F_INF)  #We need to work on this, but okay for now. Assumes everyone stays home always.
    return Delta_Exposure

def Delta_Risk_Calculator(Baseline_Mortality, Relative_Risk, PM_Concentration, Old_F_INF, New_F_INF):
    Concentration_Change_Sensitivity = 10  #ug/m3
    Delta_Exposure = Delta_Exposure_Calculator(PM_Concentration, Old_F_INF, New_F_INF)
    Delta_Risk = Baseline_Mortality * (Delta_Exposure/Concentration_Change_Sensitivity) * ((Relative_Risk-1) / Relative_Risk)
    return Delta_Risk

def Benefit_Retrofit_Calculator(VSL, Baseline_Mortality, Relative_Risk, PM_Concentration, Old_F_INF, New_F_INF):
    Delta_Risk = Delta_Risk_Calculator(Baseline_Mortality, Relative_Risk, PM_Concentration, Old_F_INF, New_F_INF) 
    Benefit_Retrofit = Delta_Risk * VSL
    return Benefit_Retrofit

def PV_Benefit_Calculator(Interest_Rate, Base_Year, Secondary_Year, VSL, Baseline_Mortality, Relative_Risk, PM_Concentration, Old_F_INF, New_F_INF):
    
    Benefit = Benefit_Retrofit_Calculator(VSL, Baseline_Mortality, Relative_Risk, PM_Concentration, Old_F_INF, New_F_INF)
    PV_Benefit = PV_Convertor(Interest_Rate, Base_Year, Secondary_Year, Benefit)
    return PV_Benefit

#%% NPV Part
def PV_Convertor(Interest_Rate, Base_Year, Secondary_Year, Value):
    
    #Interest Rate in percentage : Interest_Rate = 10
    
    Delta_Year = Secondary_Year - Base_Year
    PV = Value / (1 + (Interest_Rate/100)) ** Delta_Year
    return PV


def NPV_Calculation( PV_Cost, PV_Benefit):
    NPV = PV_Benefit - PV_Cost
    return NPV

def GRID_NPV():
    return

#%% Model Run

def iterate_GRID( AQ_Grid_gdf = init_AQ_Grids(), County_gdf = 0, year = 1981, Interest_Rate = 0.05):
    BMR, RR, VSL_1 = init_Health_Model()
    PM_Concentrations, PM_dict = init_PM_Concentrations()
    Population, Population_dict = init_Population()
    ACH50_GRID_dict = ACH50_to_Grid()
    ACH50_GRID_dict_sd = ACH50_GRID_dict['Single-Family Attached']
    
    INF_LIST = []
    b_individial_list = []
    b_pop_list = []
    
    AQ_Grid_gdf2 = AQ_Grid_gdf.copy()
    
    for IDX, row in AQ_Grid_gdf.iterrows():
        Grid_Key = (row['COL'], row['ROW'])
        if Grid_Key == (19, 1) or Grid_Key == (12, 2) or Grid_Key == (17, 4) or Grid_Key == (6, 5) or Grid_Key == (4, 6) or Grid_Key == (3, 7) or Grid_Key == (2, 9) or Grid_Key == (21, 12) or Grid_Key == (19, 13) or Grid_Key == (24, 14) or Grid_Key == (14, 15):
            b_individial_list.append(-2000)
            b_pop_list.append(-2000)
            INF_LIST.append(np.nan)
            continue
        
        PMC = PM_dict[year][ (row['COL'],row['ROW']) ]
        if Grid_Key in Population_dict.keys():
            POP = Population_dict[ (row['COL'],row['ROW']) ]
            if POP < 1000000:
                POP = 1000000
        else:
            POP = 1000000
        ##
        #b_individial = Benefit_Retrofit_Calculator(VSL_1, BMR, RR, PMC, 0.95, 0.8)
        ##
        #print(Grid_Key)
        ACH50_row = ACH50_GRID_dict_sd[Grid_Key]
        INF_RATE = ACH50_to_INF(ACH50_row)
        #print(INF_RATE)
        b_individial = PV_Benefit_Calculator(Interest_Rate, 1981, year, VSL_1, BMR, RR, PMC, INF_RATE, 0.3)
        ##
        b_pop = b_individial * POP
        INF_LIST.append(INF_RATE)
        b_individial_list.append(b_individial)
        b_pop_list.append(b_pop)
        
    AQ_Grid_gdf2['FINF'] = INF_LIST
    AQ_Grid_gdf2['Benefit_individal'] = b_individial_list
    AQ_Grid_gdf2['Benefit_pop'] = b_pop_list
    return AQ_Grid_gdf2

'''
def iterate_GRID( AQ_Grid_gdf = init_AQ_Grids(), County_gdf = 0, year = 1981, Interest_Rate = 0.05):
    BMR, RR, VSL_1 = init_Health_Model()
    PM_Concentrations, PM_dict = init_PM_Concentrations()
    Population, Population_dict = init_Population()
    
    b_individial_list = []
    b_pop_list = []
    
    AQ_Grid_gdf2 = AQ_Grid_gdf.copy()
    
    for IDX, row in AQ_Grid_gdf.iterrows():
        Grid_Key = (row['COL'],row['ROW'])
        PMC = PM_dict[year][ (row['COL'],row['ROW']) ]
        if Grid_Key in Population_dict.keys():
            POP = Population_dict[ (row['COL'],row['ROW']) ]
            if POP < 1000000:
                POP = 1000000
        else:
            POP = 1000000
        ##
        #b_individial = Benefit_Retrofit_Calculator(VSL_1, BMR, RR, PMC, 0.95, 0.8)
        ##
        ACH50_row = row['ACH50_mean']
        INF_RATE = ACH50_to_INF(ACH50_row)
        b_individial = PV_Benefit_Calculator(Interest_Rate, 1981, year, VSL_1, BMR, RR, PMC, INF_RATE, 0.3)
        ##
        b_pop = b_individial * POP
        b_individial_list.append(b_individial)
        b_pop_list.append(b_pop)
    AQ_Grid_gdf2['Benefit_individal'] = b_individial_list
    AQ_Grid_gdf2['Benefit_pop'] = b_pop_list
    return AQ_Grid_gdf2
'''

def iterate_YEAR(Interest_Rate = 0.05):
    gdf_list = []
    for year in range(1981,2011):
        new_gdf = iterate_GRID( year = year, Interest_Rate = Interest_Rate)
        gdf_list.append(new_gdf)
    
    return gdf_list

#%% Main

new_grid = iterate_GRID()
new_grid.plot( column = new_grid['Benefit_individal'], legend = True, cmap = 'turbo' )
new_grid.plot( column = new_grid['FINF'], legend = True, cmap = 'turbo' )

new_grid.plot( column = new_grid['Benefit_pop'], legend = True, cmap = 'turbo' )


year_grid_1 = iterate_YEAR(Interest_Rate = 0.05)
year_grid = iterate_YEAR(Interest_Rate = 0.15)

NPV_Plot(year_grid)
NPV_Plot(year_grid_1)

#%% Tests 1
PM_Concentrations, PM_dict = init_PM_Concentrations()

BMR, RR, VSL_1 = init_Health_Model()
PMC = PM_dict[1981][(3,5)]
DE = Delta_Exposure_Calculator( PMC, 0.8, 0.95)
RDR = Delta_Risk_Calculator(BMR,  DE, RR)
b1 = Benefit_Retrofit_Calculator(RDR ,VSL_1)
print(b1)
#%% Tests 2
test = PV_Convertor(10, 2000, 2001, 110)
print(test)

AQ_Grid_gdf = init_AQ_Grids()
print(AQ_Grid_gdf.crs)
AQ_Grid_gdf.plot()

test3 = init_County()
print(test3.crs)
test3.plot()

test4 = init_Buildings_Stock()
test4.head()

test5 = ACH50_to_County(test4, test3)
PM_Concentrations, PM_dict = init_PM_Concentrations()
PM_dict[2010][(10,5)]

test6 = ACH50_to_INF( 15.9894 )
test7, test8 = init_Population()
# Assuming test6 is your GeoDataFrame
ax = test5.plot(column='ACH50_mean', legend=True)
# Set the title of the plot
ax.set_title("ACH50")
# Show the plot
plt.show()


#%% ACH50 Test

Buildings_Stock = init_Buildings_Stock()
Buildings_Stock['ACH50_occupant'] = Buildings_Stock['ACH50'] * Buildings_Stock['occupants']
Plot_Histogram(Buildings_Stock['occupants'], 'Occupants')
plt.title('Occupants')

BT_list_test = Buildings_Stock['type'].unique().tolist()
Buildings_Stock['type'].unique().tolist()
init_AQ_Grids()

test_County = init_County()
test_ACH50 = ACH50_to_County( )
test_ACH50_2 = ACH50_to_County_2( )
test_ACH50_3 = ACH50_to_County_1()


for i in BT_list_test:
    test_County['ACH50_mean'] = test_County['FIPS'].map(test_ACH50_3[i])
    Map_Plot(test_County, test_County['ACH50_mean'], 'ACH50 per country for Buildint Type: '+ i, name = 'ACH50 per country' +i)
    
for i in BT_list_test:
    test_County['ACH50_mean'] = test_County['FIPS'].map(test_ACH50[i])
    Map_Plot(test_County, test_County['ACH50_mean'], 'ACH50 per country for Buildint Type: '+ i + '_V2', name = 'ACH50 per country_V2' +i)
#%% County to Grid Test

test_mapping = County_to_Grid()
test_building_2 = Buildings_to_Grid()

test_Grid = init_AQ_Grids()
test_ACH50_Grid = ACH50_to_Grid()


BT_list_test = Buildings_Stock['type'].unique().tolist()
for i in BT_list_test:
    test_Grid['ACH50_mean'] = test_Grid['GRID_KEY'].map(test_ACH50_Grid[i])
    Map_Plot(test_Grid, test_Grid['ACH50_mean'], 'ACH50 per GRID for Buildint Type: '+ i, name = 'ACH50 per GRID' +i)

for _, j in test_Grid.iterrows():
    INF_RATE = ACH50_to_INF(j['ACH50_mean'])
    print(INF_RATE)
    
INF_RATE = ACH50_to_INF(test_Grid['ACH50_mean'])
    